import json
import re
import urllib

import numpy
from django.core import serializers
from django.http import HttpResponse, Http404
from django.shortcuts import render

from _load_data import get_coordinates
from wines import greedy_tsp
from wines.models import Wine, WineProducer
from wines import route_planner as RP

def root(request):
    """Generate the main page"""
    return render(request, 'root.html') 

def about(request):
    """Generate the about page"""
    return render(request, 'about.html') 

def search(request):
    """Generate the search page"""
    return render(request, 'search.html') 

def search_basic(request):
    """Generate the search page"""
    return render(request, 'search_basic.html') 

def calculate(request):
    """Calculate optimal wine tour routes"""
    routes = []
    routes_ids = []
    address = None
    try:
	matrix, address, min, max = parse_query_string(request.META['QUERY_STRING'])
	routes_ids = RP.calculate_shortest_tours(address, matrix, 5, min, max)
    except ValueError as e:
	print e
	return HttpResponse(e, content_type='text/plain')
    print routes_ids
    for x in routes_ids:
        addresses = []
        for y in x:
            if y != 0:
                addresses.append(WineProducer.objects.get(id=y).address)
        routes.append((str(address[0]) + "," + str(address[1]), str(address[0]) + "," + str(address[1]), ','.join(addresses)))
    return HttpResponse(json.dumps(routes), content_type='application/json')

def build_kwargs(string):
    """Queries the database for basic filter results, returns JSON response
    `string` is a query string of constraints"""
    query_args = filter(bool, string.split('&'))
    kwargs = {}
    for arg in query_args:
	k, v = arg.split('=')
	if k.startswith('wine_num') or not v or k == 'no_filter':
	    continue
	v = urllib.unquote(v)
	if '-' in v: #Expecting two floats separated by dash
	    k += '__range'
	    v = tuple(v.split('-'))
	if ',' in v: #Expecting a comma separated list of floats
	    k += '__in'
	    v = v.split(',')
	    v = tuple([val.strip() for val in v])
	kwargs[k] = v 
    return kwargs

def query(request):
    """Sends the reponse with a serialized representations of all the wines
    that satisfy `kwargs`"""
    results = None
    kwargs = build_kwargs(request.META['QUERY_STRING'])
    try:
	results = Wine.objects.filter(**kwargs)
    except Wine.DoesNotExist:
	raise Http404
    except ValueError:
	results = []
    return HttpResponse(
		serializers.serialize('json', results, use_natural_keys=True), 
		content_type='application/json')

def parse_query_string(string):
    """Parses a query string into a usable form for greedy_tsp"""
    args = filter(bool, re.split('&?wine_num=[0-9]+&', string))
    address, min_wineries, max_wineries = [x.split('=')[1] for x in args[0].split('&')]
    constraints = args[1:]
    
    try:
	min_wineries, max_wineries = int(min_wineries), int(max_wineries)
    except ValueError:
	raise ValueError('Please enter valid integers for min and max wineries')
    if min_wineries > max_wineries:
	raise ValueError('Min wineries cannot be greater than max wineries')
    
    address = get_coordinates(address)
    if not address:
	raise ValueError('Google Geocoder could not recognize origin address')

    wines = {}
    count = 0
    max_winery_id = -1
    
    for constraint in constraints:
	wineries = set()
	kwargs = build_kwargs(constraint)
	for result in Wine.objects.filter(**kwargs):
	    wineries.add(result.wine_producer.id)
	    max_winery_id = max(max_winery_id, result.wine_producer.id)
	if not wineries:
	    raise ValueError('One wine has no satisfiable wineries')
	wines[count] = wineries
	count += 1
	#If the set is empty, the tour is not satisfiable, perhaps return error
    matrix = numpy.zeros((max_winery_id+1, count))
    for wine, wineries in wines.iteritems():
	for winery in wineries:
	    matrix[winery, wine] = 1
    
    return matrix, address, min_wineries, max_wineries
