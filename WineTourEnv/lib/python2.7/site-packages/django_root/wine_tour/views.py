import json
import re
import urllib

import numpy
from django.core import serializers
from django.http import HttpResponse, Http404
from django.shortcuts import render

from _load_data import get_coordinates
from wines import greedy_tsp
from wines.models import Wine, WineProducer
from wines import route_planner as RP

KWARGS_MAP = {
   'color__istartswith': 'Color',
   'country': 'Country',
   'percent_new_oak': 'Percent New Oak',
   'percent_new_oak__in': 'Percent New Oak',
   'percent_new_oak__range': 'Percent New Oak',
   'percentage_alcohol': 'Percentage Alcohol',
   'percentage_alcohol__range': 'Percentage Alcohol',
   'percentage_alcohol__in': 'Percentage Alcohol',
   'region': 'Region',
   'style': 'Style',
   'vintage': 'Vintage',
   'vintage__in': 'Vintage',
   'vintage__range': 'Vintage',
   'vineyard': 'Vineyard',
   'wine_sub_region': 'Wine Sub Region',
   'no_filter': 'No Filter'
}

def root(request):
    """Generate the main page"""
    return render(request, 'root.html') 

def about(request):
    """Generate the about page"""
    return render(request, 'about.html') 

def search(request):
    """Generate the search page"""
    return render(request, 'search.html') 

def search_basic(request):
    """Generate the search page"""
    return render(request, 'search_basic.html') 

def calculate(request):
    """Calculate optimal wine tour routes"""
    routes = []
    routes_ids = []
    snippets = []
    address = None
    try:
	matrix, address, min, max, winery_info = parse_query_string(request.META['QUERY_STRING'])
	print winery_info
	routes_ids = RP.calculate_shortest_tours(address, matrix, 5, min, max)
    except ValueError as e:
	print e
	return HttpResponse(e, content_type='text/plain')
    for x in routes_ids:
	addresses = []
	snippet = ''
	waypoint = 'B'
        for y in x:
            if y != 0:
		w = WineProducer.objects.get(id=y)
		addresses.append(w.address)
		if y in winery_info:
		    snippet += \
			'<b>%s. %s</b><br/>%s' % (waypoint, w.name, winery_info[y])
		else:
		    snippet += \
			'<b>%s. %s</b><br/>%s' % (waypoint, w.name,
			'<ul><li>No Filter</li></ul>')
		waypoint = chr(ord(waypoint) + 1)
	snippets.append(snippet) 
	routes.append((str(address[0]) + "," + str(address[1]), str(address[0]) + "," + str(address[1]), addresses))
		

    response = {'routes': routes, 'snippets': snippets}
    return HttpResponse(json.dumps(response), content_type='application/json')

def build_kwargs(string):
    """Queries the database for basic filter results, returns JSON response
    `string` is a query string of constraints"""
    query_args = filter(bool, string.split('&'))
    kwargs = {}
    for arg in query_args:
	k, v = arg.split('=')
	if k.startswith('wine_num') or not v or k == 'no_filter':
	    continue
	v = urllib.unquote(v)
	if '-' in v: #Expecting two floats separated by dash
	    k += '__range'
	    v = tuple(v.split('-'))
	if ',' in v: #Expecting a comma separated list of floats
	    k += '__in'
	    v = v.split(',')
	    v = tuple([val.strip() for val in v])
	kwargs[k] = v 
    return kwargs

def query(request):
    """Sends the reponse with a serialized representations of all the wines
    that satisfy `kwargs`"""
    results = None
    kwargs = build_kwargs(request.META['QUERY_STRING'])
    try:
	results = Wine.objects.filter(**kwargs)
    except Wine.DoesNotExist:
	raise Http404
    except ValueError:
	results = []
    return HttpResponse(
		serializers.serialize('json', results, use_natural_keys=True), 
		content_type='application/json')

def parse_query_string(string):
    """Parses a query string into a usable form for greedy_tsp"""
    args = filter(bool, re.split('&?wine_num=[0-9]+&', string))
    address, min_wineries, max_wineries  = [x.split('=')[1] for x in args[0].split('&')]
    constraints = args[1:]
    
    try:
	min_wineries, max_wineries = int(min_wineries), int(max_wineries)
    except ValueError:
	raise ValueError('Please enter valid integers for min and max wineries')
    if min_wineries > max_wineries:
	raise ValueError('Min wineries cannot be greater than max wineries')
    
    address = get_coordinates(address)
    if not address:
	raise ValueError('Google Geocoder could not recognize origin address')

    wines = {}
    winery_info = {}
    count = 0
    max_winery_id = -1
    
    for constraint in constraints:
	wineries = set()
	kwargs = build_kwargs(constraint)
	for result in Wine.objects.filter(**kwargs):
	    wineries.add(result.wine_producer.id)
	    max_winery_id = max(max_winery_id, result.wine_producer.id)
	if not wineries:
	    raise ValueError('One wine has no satisfiable wineries')
	wines[count] = wineries
	for winery in wineries:
	    if winery in winery_info:
		winery_info[winery] +=  dict_to_string(kwargs)
	    else:
		s = dict_to_string(kwargs)
		if s:
		    winery_info[winery] = dict_to_string(kwargs)
	count += 1
	#If the set is empty, the tour is not satisfiable, perhaps return error
    
    for winery, html in winery_info.iteritems():
	winery_info[winery] = '<ul>%s</ul>' % html
    print winery_info

    matrix = numpy.zeros((max_winery_id+1, count))
    for wine, wineries in wines.iteritems():
	for winery in wineries:
	    matrix[winery, wine] = 1
    
    return matrix, address, min_wineries, max_wineries, winery_info

def dict_to_string(dic):
    """Converts a dictionary into an HTML string"""
    s = ''
    for k, v in dic.iteritems():
	if k == 'no_filter':
	    k, v = 'No Filter', ''
	if k.endswith('range'):
	    v = '-'.join(v)
	if k.endswith('in'):
	    v = ','.join(v)
	s += '%s: %s<br/>' % (KWARGS_MAP[k], v)
    if s:
	return '<li>%s</li>' % s
    else:
	return s
	

