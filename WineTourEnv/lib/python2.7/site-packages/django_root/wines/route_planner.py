import json
import numpy
import os
import urllib2
from scipy.sparse.csgraph import dijkstra
from models import Wine, WineProducer
from operator import itemgetter
from greedy_tsp import solve_tsp_numpy
from re import sub
from math import sqrt, fabs
from collections import deque

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
METRIC = {
    'km': 1000,
    'm': 1
}

num_wineries = None
num_constraints = None
tour_distance = []
max_min_distance = 0
tolerance = 1
tolerance_percent = 0.02
level_factor = .66666

def get_coordinates(id):
    """Given the `id` of a WineProducer, return the latitude and 
    longitude of the WineProducer as a tuple"""
    response = urllib2.urlopen('http://maps.googleapis.com/maps' + \
		'/api/geocode/json?address=%s&sensor=false' \
		% WineProducer.objects.get(id=id).address.replace(' ', '+'))
    try:
	obj = json.loads(response.read())['results'][0]['geometry']['location']
	return (float(obj['lat']), float(obj['lng']))
    except (KeyError, IndexError):
	return 

def distance(coords1, coords2):
    if None in coords1 or None in coords2:
	return 9999999.9
    return sqrt((coords1[0]-coords2[0])**2 + ((coords1[1]-coords2[1])**2))

def get_distance_matrix(source_coordinates, ids):
    """Given an array of WineProducer ids, returns a distance matrix
    of the distances between each point, and a dictionary that maps
    the rows/cols to the name of the WineProducer it represents"""
    """coordinate_string = ''
    source_coordinates = '%s,%s' % source_coordinates
    coordinate_string += '%s|' % source_coordinates
    """
    coordinates = [source_coordinates]
    for id in ids:
	print id
	winery = WineProducer.objects.get(id=id)
	coordinate = (winery.lat, winery.lng)
	coordinates.append(coordinate)
    """
    coordinate_string += "|".join(coordinates)
    count = 1
    for id in ids:
	coordinates = get_coordinates(id)
	if not coordinates: continue
	coordinates = '%s,%s' % coordinates	
	coordinate_string += '%s|' % coordinates
	count += 1
    if not coordinate_string:
	raise ValueError('No valid coordinates could be obtained')
    response = urllib2.urlopen('http://maps.googleapis.com/maps/api/distancematrix/json?origins=%s&destinations=%s&sensor=false' % (coordinate_string, coordinate_string))
    obj = json.loads(response.read())
    if obj['status'] == u'OVER_QUERY_LIMIT':
	print "over query limit"
	raise ValueError('Number of addresses is too large for Google API')
    #Build distance matrix"""
    num_nodes = len(ids)
    matrix = numpy.zeros((len(ids) + 1, len(ids) + 1))
    for r in range(num_nodes + 1):
	coords1 = coordinates[r]
	for c in range(num_nodes + 1):
	    coords2 = coordinates[c]
	    #Enforce symmetry (inconsistent Google API results)
	    if r == c:
		matrix [r, c] = 0
	    elif matrix[c, r]:
		matrix[r, c] = matrix[c,r]
	    else:
		print distance(coords1,coords2)
		matrix[r, c] = distance(coords1, coords2)#metric_convert(sub(r",", ".", elem['distance']['text']))
    return matrix.tolist()

def metric_convert(string):
    distance, unit = string.split(' ')
    return float(distance) * METRIC[unit]

def get_shortest_tours(dist_matrix, constraint_matrix, num_results, min_wineries, max_wineries):
    """Given a distance matrix where the first row/column corresponds to the source, a constraint matrix for the wineries
	the number of results desired, the minimum number of wineries in a tour, and the maximum number of wineries in a tour,
	give a list of the shortest tours ordered by increasing distance"""
    
    global num_wineries, num_constraints, tour_distance, max_min_distance, tolerance, tolerance_percent, level_factor
    num_wineries = len(constraint_matrix)
    num_constraints = len(constraint_matrix[0])
    tour_distance = []
    max_min_distance = 0
    tolerance = 1
    tolerance_percent = 0.02
    level_factor = .66666
    
    def add(a, coeff, b):
	return a + coeff*b
    
    log = False
    if log: logfile = open("tour.log","w")

    
    def calculate_tour_distance(possible_tour):
	tour = [0] + [x+1 for x in possible_tour] # Because the 0 index in the distance matrix is for the source and incoming indices are one too low
	return solve_tsp_numpy(tour, dist_matrix)
    
    def made_improvement(possible_tour, indent):
	global tour_distance, max_min_distance
        calculated_tour = calculate_tour_distance(possible_tour)
        len_tour_dist = len(tour_distance)
        if log: logfile.write(indent + "Distance: " + str(calculated_tour[1]) + "\n")
        if len_tour_dist == 0:
            tour_distance.append(calculated_tour)
            max_min_distance = tour_distance[0][1]
            return max_min_distance
        elif len_tour_dist < num_results:
            old_high = tour_distance[len_tour_dist-1][1]
            tour_distance.append(calculated_tour)
            tour_distance = sorted(tour_distance, key=itemgetter(1))
            #change = tour_distance[len(tour_distance)-1][1] - max_min_distance
            max_min_distance = tour_distance[len_tour_dist][1]
            return max_min_distance-old_high
        elif calculated_tour[1] < max_min_distance:
            old_high = tour_distance[len_tour_dist-1][1]
            tour_distance[num_results-1] = calculated_tour
            tour_distance = sorted(tour_distance, key=itemgetter(1))
            max_min_distance = tour_distance[len_tour_dist-1][1]
            return max_min_distance-old_high
	return False
    
    def vec_or(vector1, vector2):
        ret = []
        for x in range(len(vector1)):
            ret.append(vector1[x] or vector2[x])
        return ret
    
    def satisfies_new_constraints(possible_tour):
        len_tour = len(possible_tour)
        new_node = possible_tour[len_tour-1]
        already_satisfied = [0] * num_constraints
        for x in range(len_tour-2):
            already_satisfied = vec_or(already_satisfied, constraint_matrix[possible_tour[x]])
        return already_satisfied != vec_or(already_satisfied, constraint_matrix[possible_tour[len_tour-1]])
        
    def meets_constraints(possible_tour):
	"""Checks whether a given possible tour satisfies all of the constraints"""
	constraint_vector = [0]*num_constraints
	for x in possible_tour:
	    constraint_vector = vec_or(constraint_vector, constraint_matrix[x])
	for y in constraint_vector:
	    if not y:
		return False
	return True
    
    def build_tour_list(consecutive_nonimprovements, possible_tour, level, indent, branch_improvement=False, one_deep_from_constraint_satisfaction = False):
	len_current_tour = len(possible_tour)
        if log: logfile.write(indent + "Possible tour: " + str(possible_tour)+"\n" + indent + "Consecutive nonimprovements: " + str(consecutive_nonimprovements) + "\n")
        if (consecutive_nonimprovements > tolerance + level*(1+level_factor) and len(tour_distance) == num_results) or len_current_tour > max_wineries:
            return branch_improvement
        if meets_constraints(possible_tour):
            if log: logfile.write(indent + "Meets constraints\n")
            if len_current_tour >= min_wineries:
                var = made_improvement(possible_tour, indent)
                if var and (var > 0 or fabs(var)/(tour_distance[len(tour_distance)-1][1] + fabs(var)) >= tolerance_percent):
                    if log: logfile.write(indent + "Made improvement: " + str(var) + " " + str(fabs(var)/(tour_distance[len(tour_distance)-1][1] + fabs(var))) + " " + str(tolerance_percent) + "\n")
                    if possible_tour[len_current_tour-1] + 1 < num_wineries:
                        if not one_deep_from_constraint_satisfaction:
                            build_tour_list(0, possible_tour + [possible_tour[len_current_tour-1] + 1], level+1, indent + "    ", one_deep_from_constraint_satisfaction = True)
                            build_tour_list(0, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], level, indent + "    ", branch_improvement)
                        else:
                            build_tour_list(0, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], level, indent + "    ", branch_improvement, True)
                    else:
                        return True
                else:
                    if log: logfile.write(indent + "Didn't make improvement\n")
                    if possible_tour[len_current_tour-1] + 1 < num_wineries:
                        build_tour_list(consecutive_nonimprovements + 1, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], level, indent + "    ", branch_improvement, one_deep_from_constraint_satisfaction)
                    else:
                        return branch_improvement
            else:
                if possible_tour[len_current_tour-1] + 1 < num_wineries:
                    if build_tour_list(0, possible_tour + [possible_tour[len_current_tour-1] + 1], level+1, indent + "    "):
                        build_tour_list(0, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], level, indent + "    ", branch_improvement)
                    else:
                        build_tour_list(consecutive_nonimprovements+1, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], level, indent + "    ", branch_improvement)
                else:
                    return branch_improvement
        elif possible_tour[len_current_tour-1] + 1 < num_wineries:
            if not satisfies_new_constraints(possible_tour):
                if log: logfile.write(indent + "New constraint not met\n")
                build_tour_list(consecutive_nonimprovements, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], level, indent + "    ", branch_improvement)
            elif len_current_tour < min_wineries or len_current_tour < num_constraints:
                if build_tour_list(0, possible_tour + [possible_tour[len_current_tour-1]+1], level+1, indent + "    "):
                    build_tour_list(0, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], level, indent + "    ", branch_improvement)
                else:
                    build_tour_list(consecutive_nonimprovements + 1, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], level, indent + "    ", branch_improvement)
            else:
                build_tour_list(consecutive_nonimprovements + 1, [possible_tour[x] for x in range(len_current_tour-1)] + [possible_tour[len_current_tour-1] + 1], level, indent + "    ", branch_improvement)
        else:
            return branch_improvement
    if log: logfile.close()
    build_tour_list(0, [0], 1, "")
    routes = []
    for x in range(len(tour_distance)):
        routes.append(tour_distance[x][0])
    return routes

def sort_by_dist_from_source(dist_matrix, constraint_matrix, winery_ids):
    dists_from_source = [x for x in dist_matrix[0]]
    max_dist = max(dists_from_source)
    ids_by_increasing_dist = []
    indices_by_inc_dist = []
    num_nodes = len(dist_matrix)
    new_dist_matrix = []
    new_constraint_matrix = []
    for i in range(len(dists_from_source)):
	index = dists_from_source.index(min(dists_from_source))
	indices_by_inc_dist.append(index)
	ids_by_increasing_dist.append(winery_ids[index])
	dists_from_source[index] = max_dist + 1
    for i in range(num_nodes):
	row = []
	for j in range(num_nodes):
	    row.append(dist_matrix[indices_by_inc_dist[i]][indices_by_inc_dist[j]])
	new_dist_matrix.append(row)
    for i in range(num_nodes-1):
	new_constraint_matrix.append(constraint_matrix[indices_by_inc_dist[i+1]-1])
    return new_dist_matrix, new_constraint_matrix, ids_by_increasing_dist
	    

def process_constraints(constraint_matrix):
    new_matrix = []
    winery_ids = []
    for i in range(len(constraint_matrix)):
	if 1 in constraint_matrix[i]:
	    new_matrix.append(constraint_matrix[i])
	    winery_ids.append(i)
    #winery_ids = [winery_ids[i] for i in range(9)]
    #new_matrix = [new_matrix[i] for i in range(9)]
    print winery_ids
    return winery_ids, new_matrix

def calculate_shortest_tours(source_coordinates, constraint_matrix, num_results, min_wineries, max_wineries):
    winery_ids, constraint_matrix = process_constraints(constraint_matrix)
    dist_matrix = get_distance_matrix(source_coordinates, winery_ids)
    winery_ids = deque(winery_ids)
    winery_ids.appendleft(0)
    winery_ids = list(winery_ids)
    print winery_ids
    dist_matrix, constraint_matrix, new_id_to_old = sort_by_dist_from_source(dist_matrix, constraint_matrix, winery_ids)
    print new_id_to_old
    print dist_matrix
    routes_new_id = get_shortest_tours(dist_matrix, constraint_matrix, num_results, min_wineries, max_wineries)
    routes_old_id = []
    print new_id_to_old
    for x in routes_new_id:
	print x
	routes_old_id.append([new_id_to_old[i] for i in x])
    return routes_old_id