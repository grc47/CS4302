import json
import numpy
import os
import urllib2

from scipy.sparse.csgraph import dijkstra

from models import Wine, WineProducer

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
METRIC = {
    'km': 1000,
    'm': 1
}

def get_coordinates(id):
    """Given the `id` of a WineProducer, return the latitude and 
    longitude of the WineProducer as a tuple"""
    response = urllib2.urlopen('http://maps.googleapis.com/maps' + \
		'/api/geocode/json?address=%s&sensor=false' \
		% WineProducer.objects.get(id=id).address.replace(' ', '+'))
    try:
	obj = json.loads(response.read())['results'][0]['geometry']['location']
	return (float(obj['lat']), float(obj['lng']))
    except (KeyError, IndexError):
	return 

def get_distance_matrix(ids, my_lat=None, my_lng=None, my_name=None):
    """Given an array of WineProducer ids, returns a distance matrix
    of the distances between each point, and a dictionary that maps
    the rows/cols to the name of the WineProducer it represents"""
    row_to_name = {}
    coordinate_string = ''
    count = 0
    for id in ids:
	coordinates = get_coordinates(id)
	if not coordinates: continue
	coordinates = '%s,%s' % coordinates	
	coordinate_string += '%s|' % coordinates
	row_to_name[count] = WineProducer.objects.get(id=id).name
	count += 1
    if not coordinate_string:
	raise ValueError('No valid coordinates could be obtained')
    if my_lat and my_lng: 
	coordinate_string += '%s,%s|%s,%s|' % (str(my_lat), str(my_lng),
						str(my_lat), str(my_lng))
	row_to_name[count] = my_name if my_name else 'My Location'
	row_to_name[count+1] = my_name if my_name else 'My Location'
    response = urllib2.urlopen('http://maps.googleapis.com/maps' + \
		'/api/distancematrix/json?origins=%s&destinations=%s&sensor=false' \
		% (coordinate_string, coordinate_string))
    obj = json.loads(response.read())
    if obj['status'] == u'OVER_QUERY_LIMIT':
	raise ValueError('Number of addresses is too large for Google API')
   
    #Build distance matrix
    print obj
    matrix = numpy.zeros((len(row_to_name), len(row_to_name)))
    r = 0
    for row in obj['rows']:
	c = 0
	for elem in row['elements']:
	    #Enforce symmetry (inconsistent Google API results)
	    if r == c:
		matrix [r, c] = 0
	    elif matrix[c, r]:
	    	matrix[r, c] = matrix[c,r]
	    else:
		try:
		    matrix[r, c] = metric_convert(elem['distance']['text'])
		except KeyError:
		    raise ValueError('Custom lat/lng coordinates are invalid')
	    c += 1
	r += 1

    return (matrix, row_to_name)

def metric_convert(string):
    distance, unit = string.split(' ')
    return float(distance.replace(',', '')) * METRIC[unit]
