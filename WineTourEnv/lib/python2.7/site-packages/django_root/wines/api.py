import os

import yaml
from models import Wine, WineProducer
from rdflib import ConjunctiveGraph, URIRef, Literal, Namespace, RDF
from tastypie import fields
from tastypie import http
from tastypie.authentication import Authentication
from tastypie.authorization import Authorization
from tastypie.exceptions import ImmediateHttpResponse
from tastypie.resources import ModelResource
from tastypie.serializers import Serializer
from tastypie.validation import Validation

import wine_tour

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

CONTENT_TYPES = {
    'xml': 'application/xml',
    'json': 'application/json',
    'jsonp': 'text/javascript',
    'yaml': 'text/yaml',
    'rdf': 'application/rdf+xml',
    'ttl': 'text/turtle'
}

#Reversed version of CONTENT_TYPES
REV_CONTENT_TYPES = dict((v,k) for k, v in CONTENT_TYPES.iteritems()) 

REQUIRED_WINE_FIELDS = set([
    'name',
    'style',
    'country',
    'region',
    'wine_producer',
    'wine_type'
])

ALLOWABLE_WINE_FIELDS = set([
    'name',
    'appellation',
    'color', 
    'country',
    'fruit_source',
    'percent_new_oak',
    'percentage_alcohol',
    'region',
    'style',
    'vineyard',
    'vintage',
    'wine_producer',
    'wine_sub_region',
    'wine_type',
    'id',
    'resource_uri'
])

REQUIRED_WINE_PRODUCER_FIELDS = set([
    'name',
    'address',
])

ALLOWABLE_WINE_PRODUCER_FIELDS = set([
    'name',
    'address',
    'lat',
    'lng',
    'id'
])

class CustomResource(ModelResource):
    def determine_format(self, request):
	"""Provide logic to provide JSON responses as default"""
	if 'format' in request.GET:
	    if request.GET['format'] in CONTENT_TYPES:
		return CONTENT_TYPES[request.GET['format']]
	if 'HTTP_ACCEPT' in request.META and request.META['HTTP_ACCEPT']:
	    if request.META['HTTP_ACCEPT'] in REV_CONTENT_TYPES:
		return request.META['HTTP_ACCEPT']
	return 'application/json'

    def obj_get(self, request=None, **kwargs):
	"""If no format is explicitly given with the query string,
	use the 'Accept' request header to perform a 303 redirect"""
	if request.method == 'GET' and not 'format' in request.GET:
	    format = REV_CONTENT_TYPES[request.META['HTTP_ACCEPT']] \
			if 'HTTP_ACCEPT' in request.META and \
			request.META['HTTP_ACCEPT'] in REV_CONTENT_TYPES else 'json'
	    see_other = http.HttpSeeOther()
	    see_other['Location'] = '%s?format=%s' % (request.path, format)
	    if request.META['QUERY_STRING']:
		see_other['Location'] += '&%s' % request.META['QUERY_STRING']
	    raise ImmediateHttpResponse(see_other)
	else:
	    return super(CustomResource, self).obj_get(request, **kwargs)

    def obj_get_list(self, request=None, **kwargs):
	if request.method == 'GET' and not 'format' in request.GET:
	    format = REV_CONTENT_TYPES[request.META['HTTP_ACCEPT']] \
			if 'HTTP_ACCEPT' in request.META and \
			request.META['HTTP_ACCEPT'] in REV_CONTENT_TYPES else 'json'
	    see_other = http.HttpSeeOther()
	    see_other['Location'] = '%s?format=%s' % (request.path, format)
	    if request.META['QUERY_STRING']:
		see_other['Location'] += '&%s' % request.META['QUERY_STRING']
	    raise ImmediateHttpResponse(see_other)
	else:
	    return super(CustomResource, self).obj_get_list(request, **kwargs)
		

    def rm_slash(self, uri):
    	"""Remove trailing slash if it exists"""
    	return uri[:-1] if uri.endswith('/') else uri


class CustomSerializer(Serializer):
    formats = ['json', 'jsonp', 'xml', 'yaml', 'rdf', 'ttl']
    content_types = CONTENT_TYPES

    def to_yaml(self, data, options=None):
	"""Remove '!!python/unicode' from all yaml fields"""
	return yaml.safe_dump(self.to_simple(data, options))
    
    def to_rdf(self, data, options=None):
	return self.serialize_rdf(data, 'pretty-xml', options)

    def to_ttl(self, data, options=None):
	return self.serialize_rdf(data, 'turtle', options)
    
    def serialize_rdf(self, data, format, options=None):
	"""Serialize a representation of type `format` from the RDF graph"""
	resource_uris = None
	exhaustive = False
	if isinstance(data, dict):
	    resource_uris = ['http://127.0.0.1:8000' + obj.data['resource_uri'] for obj in data['objects']]
	else:
	    resource_uris = ['http://127.0.0.1:8000' + data.data['resource_uri']]
	resource_uris = [uri[0:-1] if uri.endswith('/') else uri for uri in resource_uris]
	g = wine_tour.RDF_DB.query_graph(subj=resource_uris, exhaustive=exhaustive)
	return g.serialize(format=format) 

class WineValidation(Validation):
    def is_valid(self, bundle, request=None):
	if not bundle.data:
	    return {'__all__': 'No data was detected'}

	missing_fields = []
	invalid_fields = []
	
	for field in REQUIRED_WINE_FIELDS:
	    if not field in bundle.data.keys():
		missing_fields.append(field)
	for key in bundle.data.keys():
	    if not key in ALLOWABLE_WINE_FIELDS:
		invalid_fields.append(key)

	errors = missing_fields + invalid_fields if request.method != 'PATCH' \
	    else invalid_fields
	
	if errors:
	    return 'Missing fields: %s; Invalid fields: %s' % \
		    (', '.join(missing_fields), ', '.join(invalid_fields))
	else:
	    return errors

class WineProducerValidation(Validation):
    def is_valid(self, bundle, request=None):
	if not bundle.data:
	    return {'__all__': 'No data was detected'}

	missing_fields = []
	invalid_fields = []
	
	for field in REQUIRED_WINE_PRODUCER_FIELDS:
	    if not field in bundle.data.keys():
		missing_fields.append(field)
	for key in bundle.data.keys():
	    if not key in ALLOWABLE_WINE_PRODUCER_FIELDS:
		invalid_fields.append(key)

	errors = missing_fields + invalid_fields if request.method != 'PATCH' \
	    else invalid_fields
	
	if errors:
	    return 'Missing fields: %s; Invalid fields: %s' % \
		    (', '.join(missing_fields), ', '.join(invalid_fields))
	else:
	    return errors

class WineProducerResource(CustomResource):
    wine = fields.ToManyField('wines.api.WineResource', 'wine_set', 
			     related_name='wine_producer', null=True)
    class Meta:
	queryset = WineProducer.objects.all()
	resource_name = 'wine_producer'
	authentication = Authentication() #allows all access
	authorization = Authorization() #allows all access
	serializer = CustomSerializer()
	validation = WineProducerValidation()
    
    def extract_bundle_info(self, bundle):
	"""Given a bundle, return a tuple containing the modified wine's information
	Format is (WineProducer's ID, WineProducer's URI, Wine's URI)"""
    	base_uri = 'http://127.0.0.1:8000'
	id = bundle.data['id'] if 'id' in bundle.data else bundle.data['pk']
    	resource_uri = bundle.data['resource_uri'] if 'resource_uri' in \
    	    bundle.data else '/api/v1/wine_producer/%s' % id 
	wines = []
	try:
	    wines = Wine.objects.get(wine_producer=id)
	except Wine.DoesNotExist:
	    pass
	if not isinstance(wines, list):
	    wines = [wines]
	return (id, 'http://127.0.0.1:8000/api/v1/wine_producer/%s' % id, 
		['http://127.0.0.1:8000/api/v1/wine/%s' % wine.id \
		    for wine in wines]) 

    def mimic_bundle_info(self, pk):
	"""Mimics the behavior of extract_bundle_info, but without a bundle"""
    	if not pk:
	    raise TypeError('No argument passed to obj_delete')
	wines = []
	try:
	    wines = Wine.objects.get(wine_producer=pk)
	except Wine.DoesNotExist:
	    pass
	if not isinstance(wines, list):
	    wines = [wines]
	return (pk, 'http://127.0.0.1:8000/api/v1/wine_producer/%s' % pk, 
		['http://127.0.0.1:8000/api/v1/wine/%s' % wine.id \
		    for wine in wines]) 
    
    def sync_rdf_db(self, args, delete=False):
	"""Sync the in memory RDF with the Django database. `args` is a tuple
	containing (Wine's ID, Wine's URI, WineProducer's URI) """
	g = wine_tour.RDF_DB.query_graph(subj=args[1], exhaustive=True)
	wine_tour.RDF_DB.remove_resource(
    	    self.rm_slash(args[1]))
	for wine in args[2]:
	    wine_tour.RDF_DB.remove_resource(
		self.rm_slash(wine))
	if not delete:
	    wine_tour.RDF_DB.add_wine_producer(WineProducer.objects.get(
		id=int(args[0])))
	    for wine in args[2]:
		wine_tour.RDF_DB.add_wine(Wine.objects.get(
		    id=int(self.rm_slash(wine).rpartition('/')[2])))
    
    def hydrate_wine(self, bundle):
    	"""Use the provided Wine ID to properly link a PUT, POST,
    	or PATCH to the correct Wine instance in the db"""
    	#Workaround since tastypie has bug and calls hydrate more than once
    	if not 'wine' in bundle.data or bundle.data['wine']:
    	    return bundle
	try:
    	    bundle.data['wine'] = ['api/v1/wine/%i' % int(x) for x in bundle.data['wine']]
    	except ValueError:
    	    return bundle
    	return bundle

class WineResource(CustomResource):
    wine_producer = fields.ForeignKey(WineProducerResource, 'wine_producer')
    
    class Meta:
	queryset = Wine.objects.all()
	resource_name = 'wine'
	authentication = Authentication() #allows all access
	authorization = Authorization() #allows all access
	validation = WineValidation()
	serializer = CustomSerializer()
	filtering = {
	    'percent_new_oak': ('exact', 'lt', 'gt', 'lte', 'gte'),
	    'percentage_alcohol': ('exact', 'lt', 'gt', 'lte', 'gte'),
	    'color': ('exact', 'startswith'),
	    'style': ('exact', 'startswith')
	    
	}

    def extract_bundle_info(self, bundle):
	"""Given a bundle, return a tuple containing the modified wine's information
	Format is (Wine's ID, Wine's URI, WineProducer's URI)"""
    	base_uri = 'http://127.0.0.1:8000'
	id = bundle.data['id'] if 'id' in bundle.data else bundle.data['pk']
    	resource_uri = bundle.data['resource_uri'] if 'resource_uri' in \
    	    bundle.data else '/api/v1/wine/%s' % id 
	producer_uri = base_uri + bundle.data['wine_producer']
	return (id, base_uri + resource_uri, base_uri + producer_uri)

    def mimic_bundle_info(self, pk):
	"""Mimics the behavior of extract_bundle_info, but without a bundle"""
    	if not pk:
	    raise TypeError('No argument passed to obj_delete')
	return (pk, 'http://127.0.0.1:8000/api/v1/wine/%s' % pk, 
		    'http://127.0.0.1:8000/api/v1/wine_producer/%s' % \
		    Wine.objects.get(id=pk).wine_producer.id)
    
    def sync_rdf_db(self, args, delete=False):
	"""Sync the in memory RDF with the Django database. `args` is a tuple
	containing (Wine's ID, Wine's URI, WineProducer's URI) """
	wine_tour.RDF_DB.remove_resource(
    	    self.rm_slash(args[1]))
    	wine_tour.RDF_DB.remove_resource(
    	    self.rm_slash(args[2]))
	if not delete:
	    wine_tour.RDF_DB.add_wine(Wine.objects.get(id=args[0]))
	    wine_tour.RDF_DB.add_wine_producer(WineProducer.objects.get(
		    id=int(self.rm_slash(args[2]).rpartition('/')[2])))
    
    def hydrate_wine_producer(self, bundle):
	"""Use the provided WineProducer ID to properly link a PUT, POST,
	or PATCH to the correct WineProducer instance in the db"""
	#Workaround since tastypie has bug and calls hydrate more than once
	if not 'wine_producer' in bundle.data:
	    return bundle
	try:
	    int(bundle.data['wine_producer'])
	except ValueError:
	    return bundle
	bundle.data['wine_producer'] = '/api/v1/wine_producer/%s/' % \
					    bundle.data['wine_producer']
	return bundle
