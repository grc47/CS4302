import datetime
import json
import os
import subprocess
import sys
import urllib

from lxml import etree
from unidecode import unidecode

OUTPUT_DIR = os.path.dirname(os.path.abspath(__file__))

#A dictionary of indices that must be present in order for the
#entry to be considered valid and not thrown out
INDICES = {
    'wine': [-3],
    'beer': [4]
}

#A set of keywords in the existing data set that will be used
#for Google Maps API queries in def geocode()
GEOCODE_KEYWORDS = set([
    'brewery_brand',
    'from_region',
    'wine_producer',
    'region'
])


class TSVParser:
    """A class to parse a TSV file and create XML and JSON
    representations of it"""
    
    def __init__(self, infile, style):
	"""Returns a dictionary representation of the TSV files
	`infile` of beverage type `style`"""
	tsv = None
	with open(infile, 'r') as f:
	    tsv = f.readlines()
	
	self.style = style
	self.titles = {}
	self.data = []
	count = 0

	#Establish self.titles
	for title in tsv[0].split('\t'):
	    self.titles[count] = title.strip()
	    count += 1
	
	#Establish self.data, throw out incomplete entries
	for line in tsv[1:]:
	    if self.check_sparse(line.split('\t')):
		clean_data = []
		for datum in line.split('\t'):
		    clean_data.append(unidecode(datum.strip()))
		self.data.append(clean_data)
    
    def check_sparse(self, lst):
	"""Returns True if an entry is non-sparse according to INDICES"""
	return all(lst[i] for i in INDICES[self.style]) 

    def generate_XML(self):
	"""Generates an XML representation of the TSV file"""
	#Create the XML
	root = etree.Element('%s_catalogue' % self.style)
	
	for instance in self.data:
	    sub_root = etree.SubElement(root, self.style)

	    geocode_terms = []
	    for i in range(len(instance)):
		etree.SubElement(sub_root, self.titles[i]).text = instance[i]
		if self.titles[i] in GEOCODE_KEYWORDS:
		    geocode_terms.extend(instance[i].split(' '))
	    etree.SubElement(sub_root, 'address').text = result
	    self.geocode(' '.join(geocode_terms))

	#Write the XML
	f = open('./%s_catalogue.xml' % self.style, 'w')
	f.write('<?xml version="1.0" encoding="UTF-8" ?>\n\n')
	now = datetime.datetime.now()
	header='<!-- %s_catalogue.xml  Created: ' % self.style + \
	    now.strftime('%Y-%m-%d %H:%M') + ' -->\n\n'
	f.write(header)
	f.write(etree.tostring(root, pretty_print=True))
	f.close()

    def generate_JSON(self):
	"""Generates a JSON Django model fixture of the TSV file"""
	#Create the JSON object
	json_obj = []
	pk = 1

	for instance in self.data:
	    attributes = {'model': 'wines.wine', 'pk': pk}

	    fields = {'fields': {}}
	    geocode_terms= []
	    for i in range(0,len(instance)):
		#Remove useless data fields
		if (self.titles[i] == 'grape_variety' or self.titles[i] == 'nv'
			or self.titles[i] == 'id'):
		    continue
		
		if instance[i]:	
		    if self.titles[i] == 'vintage':
			#Remove vintage ranges
			fields['fields'][self.titles[i]] = instance[i][0:4]
		    else:
			fields['fields'][self.titles[i]] = instance[i]
		if self.titles[i] in GEOCODE_KEYWORDS:
		    geocode_terms.extend(instance[i].split(' '))
	    fields['fields'].update({'address': self.geocode(' '.join(geocode_terms))})
	    
	    #Throw out data with null addresses
	    if not fields['fields']['address']:
		continue
	    attributes.update(fields)
	    json_obj.append(attributes)
	    pk += 1
	
	#Write the JSON file
	filename = '%s_catalogue_fixture.json' % self.style
	f = open(os.path.join(OUTPUT_DIR, filename), 'w')
	f.write(json.dumps(json_obj, sort_keys=True, indent=4))
	f.close()

    def geocode(self, name):
	"""Given a business name `name`, returns the best address match
	using the Google Maps API"""
	if not name:
	    return
	#Build a '+' delimited query string
	query = urllib.quote('+'.join(name.split(' ')))
	html = subprocess.check_output(
	    ['curl', '-i', 'http://maps.google.com/maps?q=%s' % query])
	#Find the slice of text that contains the most relevant address
	index = html.find('icon_id:')
	substring = html[index:index+500].split(':')
	for i in range(len(substring)):
	    if substring[i].find('laddr') != -1:
		return unidecode(substring[i+1].split('\'')[1].decode('string-escape'))

    def __repr__(self):
	"""A string representation of the data in the CSV"""
	valid = 0
	s = ''
	for x in range(len(self.data)): 
	    for i in range(len(self.titles) - 1):
		s += '%s, %s\n' % (self.titles[i], str(self.data[x][i]))
		valid += 1
	    s += '----------\n'

	s += 'Valid entries: %i\n' % valid
	return s

if __name__ == '__main__':
    if len(sys.argv) < 3:
	print 'Usage: prune_data.py `/path/to/tsv/` `style_of_libation`'
    else:
	x = TSVParser(sys.argv[1], sys.argv[2])
	x.generate_JSON()
